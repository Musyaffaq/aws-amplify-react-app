{"ast":null,"code":"export function attachEventProps(node, newProps, oldProps) {\n  if (oldProps === void 0) {\n    oldProps = {};\n  }\n\n  var className = getClassName(node.classList, newProps, oldProps);\n\n  if (className) {\n    node.className = className;\n  }\n\n  Object.keys(newProps).forEach(function (name) {\n    if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {\n      return;\n    }\n\n    if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n      var eventName = name.substring(2);\n      var eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n\n      if (!isCoveredByReact(eventNameLc)) {\n        syncEvent(node, eventNameLc, newProps[name]);\n      }\n    } else {\n      node[name] = newProps[name];\n    }\n  });\n}\nexport function getClassName(classList, newProps, oldProps) {\n  // map the classes to Maps for performance\n  var currentClasses = arrayToMap(classList);\n  var incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);\n  var oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);\n  var finalClassNames = []; // loop through each of the current classes on the component\n  // to see if it should be a part of the classNames added\n\n  currentClasses.forEach(function (currentClass) {\n    if (incomingPropClasses.has(currentClass)) {\n      // add it as its already included in classnames coming in from newProps\n      finalClassNames.push(currentClass);\n      incomingPropClasses.delete(currentClass);\n    } else if (!oldPropClasses.has(currentClass)) {\n      // add it as it has NOT been removed by user\n      finalClassNames.push(currentClass);\n    }\n  });\n  incomingPropClasses.forEach(function (s) {\n    return finalClassNames.push(s);\n  });\n  return finalClassNames.join(' ');\n}\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\n\nexport function isCoveredByReact(eventNameSuffix, doc) {\n  if (doc === void 0) {\n    doc = document;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = (eventName in doc);\n\n  if (!isSupported) {\n    var element = doc.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n}\nexport function syncEvent(node, eventName, newEventHandler) {\n  var eventStore = node.__events || (node.__events = {});\n  var oldEventHandler = eventStore[eventName]; // Remove old listener so they don't double up.\n\n  if (oldEventHandler) {\n    node.removeEventListener(eventName, oldEventHandler);\n  }\n\n  if (newEventHandler != null) {\n    // Bind new listener.\n    node.addEventListener(eventName, eventStore[eventName] = function handler(e) {\n      newEventHandler.call(this, e);\n    });\n  }\n}\n\nfunction arrayToMap(arr) {\n  var map = new Map();\n  arr.forEach(function (s) {\n    return map.set(s, s);\n  });\n  return map;\n}","map":{"version":3,"mappings":"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","names":["attachEventProps","node","newProps","oldProps","className","getClassName","classList","Object","keys","forEach","name","indexOf","toUpperCase","eventName","substring","eventNameLc","toLowerCase","isCoveredByReact","syncEvent","currentClasses","arrayToMap","incomingPropClasses","split","oldPropClasses","finalClassNames","has","currentClass","push","delete","s","join","eventNameSuffix","doc","isSupported","element","createElement","setAttribute","newEventHandler","eventStore","__events","oldEventHandler","removeEventListener","addEventListener","handler","e","call","arr","map","Map","set"],"sources":["/Users/musyaffaq/Documents/GitHub/aws-amplify-react-app/node_modules/@aws-amplify/ui-react/src/react-component-lib/utils/attachEventProps.ts"],"sourcesContent":["export function attachEventProps(node: HTMLElement, newProps: any, oldProps: any = {}) {\n  const className = getClassName(node.classList, newProps, oldProps);\n  if (className) {\n    node.className = className;\n  }\n\n  Object.keys(newProps).forEach(name => {\n    if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {\n      return;\n    }\n    if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n      const eventName = name.substring(2);\n      const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n\n      if (!isCoveredByReact(eventNameLc)) {\n        syncEvent(node, eventNameLc, newProps[name]);\n      }\n    } else {\n      (node as any)[name] = newProps[name];\n    }\n  });\n}\n\nexport function getClassName(classList: DOMTokenList, newProps: any, oldProps: any) {\n  // map the classes to Maps for performance\n  const currentClasses = arrayToMap(classList);\n  const incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);\n  const oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);\n  const finalClassNames: string[] = [];\n  // loop through each of the current classes on the component\n  // to see if it should be a part of the classNames added\n  currentClasses.forEach(currentClass => {\n    if (incomingPropClasses.has(currentClass)) {\n      // add it as its already included in classnames coming in from newProps\n      finalClassNames.push(currentClass);\n      incomingPropClasses.delete(currentClass);\n    } else if (!oldPropClasses.has(currentClass)) {\n      // add it as it has NOT been removed by user\n      finalClassNames.push(currentClass);\n    }\n  });\n  incomingPropClasses.forEach(s => finalClassNames.push(s));\n  return finalClassNames.join(' ');\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nexport function isCoveredByReact(eventNameSuffix: string, doc: Document = document) {\n  const eventName = 'on' + eventNameSuffix;\n  let isSupported = eventName in doc;\n\n  if (!isSupported) {\n    const element = doc.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof (element as any)[eventName] === 'function';\n  }\n\n  return isSupported;\n}\n\nexport function syncEvent(node: Element, eventName: string, newEventHandler: (e: Event) => any) {\n  const eventStore = (node as any).__events || ((node as any).__events = {});\n  const oldEventHandler = eventStore[eventName];\n\n  // Remove old listener so they don't double up.\n  if (oldEventHandler) {\n    node.removeEventListener(eventName, oldEventHandler);\n  }\n\n  if (newEventHandler != null) {\n    // Bind new listener.\n    node.addEventListener(\n      eventName,\n      (eventStore[eventName] = function handler(e: Event) {\n        newEventHandler.call(this, e);\n      }),\n    );\n  }\n}\n\nfunction arrayToMap(arr: string[] | DOMTokenList) {\n  const map = new Map<string, string>();\n  (arr as string[]).forEach((s: string) => map.set(s, s));\n  return map;\n}\n"]},"metadata":{},"sourceType":"module"}